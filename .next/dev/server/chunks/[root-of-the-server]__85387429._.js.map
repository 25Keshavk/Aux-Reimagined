{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 124, "column": 0}, "map": {"version":3,"sources":["file:///Users/keshuk/Desktop/Aux-Reimagined/lib/redis.ts"],"sourcesContent":["import { createClient } from \"redis\";\n\ntype GlobalWithRedis = typeof globalThis & { __redisClient?: ReturnType<typeof createClient> };\n\nexport async function getRedis() {\n  const url = process.env.REDIS_URL;\n  if (!url) throw new Error(\"Missing env var: REDIS_URL\");\n\n  const g = globalThis as GlobalWithRedis;\n\n  if (!g.__redisClient) {\n    g.__redisClient = createClient({ url });\n    g.__redisClient.on(\"error\", (err) => console.error(\"Redis error:\", err));\n  }\n\n  if (!g.__redisClient.isOpen) {\n    await g.__redisClient.connect();\n  }\n\n  return g.__redisClient;\n}\n"],"names":[],"mappings":";;;;AAAA;;AAIO,eAAe;IACpB,MAAM,MAAM,QAAQ,GAAG,CAAC,SAAS;IACjC,IAAI,CAAC,KAAK,MAAM,IAAI,MAAM;IAE1B,MAAM,IAAI;IAEV,IAAI,CAAC,EAAE,aAAa,EAAE;QACpB,EAAE,aAAa,GAAG,IAAA,wJAAY,EAAC;YAAE;QAAI;QACrC,EAAE,aAAa,CAAC,EAAE,CAAC,SAAS,CAAC,MAAQ,QAAQ,KAAK,CAAC,gBAAgB;IACrE;IAEA,IAAI,CAAC,EAAE,aAAa,CAAC,MAAM,EAAE;QAC3B,MAAM,EAAE,aAAa,CAAC,OAAO;IAC/B;IAEA,OAAO,EAAE,aAAa;AACxB"}},
    {"offset": {"line": 149, "column": 0}, "map": {"version":3,"sources":["file:///Users/keshuk/Desktop/Aux-Reimagined/lib/rooms.ts"],"sourcesContent":["import crypto from \"crypto\";\nimport { getRedis } from \"./redis\";\n\nexport type Track = {\n  id: string;\n  name: string;\n  artist: string;\n  artworkUrl?: string;\n  votes: number;\n  addedAt: number;\n};\n\nexport type Room = {\n  id: string;\n  createdAt: number;\n  mode: \"voted\" | \"shuffle\";\n  queue: Track[];\n  nowPlaying?: Track;\n};\n\nfunction kMeta(id: string) { return `aux:room:${id}:meta`; }\nfunction kQueue(id: string) { return `aux:room:${id}:queue`; }\nfunction kTracks(id: string) { return `aux:room:${id}:tracks`; }\nfunction kAdded(id: string) { return `aux:room:${id}:addedAt`; }\nfunction kUp(id: string, tid: string) { return `aux:room:${id}:up:${tid}`; }\nfunction kDown(id: string, tid: string) { return `aux:room:${id}:down:${tid}`; }\n\nfunction randCode(len = 6) {\n  const chars = \"ABCDEFGHJKLMNPQRSTUVWXYZ23456789\";\n  let s = \"\";\n  for (let i = 0; i < len; i++) s += chars[Math.floor(Math.random() * chars.length)];\n  return s;\n}\n\nfunction genHostKey() {\n  return crypto.randomBytes(16).toString(\"hex\");\n}\n\nexport async function createRoom(): Promise<{ roomId: string; hostKey: string }> {\n  const redis = await getRedis();\n  let id = randCode(6);\n  while (await redis.exists(kMeta(id))) id = randCode(6);\n\n  const hostKey = genHostKey();\n  const createdAt = Date.now();\n\n  await redis.hSet(kMeta(id), {\n    createdAt: String(createdAt),\n    hostKey,\n    mode: \"voted\",\n    nowPlayingJson: \"\",\n  });\n\n  return { roomId: id, hostKey };\n}\n\nexport async function requireHost(roomId: string, hostKey: string | null) {\n  const redis = await getRedis();\n  const real = await redis.hGet(kMeta(roomId), \"hostKey\");\n  if (!real || !hostKey || real !== hostKey) throw new Error(\"Host only\");\n}\n\nexport async function getRoom(roomId: string): Promise<Room | null> {\n  const redis = await getRedis();\n  const meta = await redis.hGetAll(kMeta(roomId));\n  if (!meta || Object.keys(meta).length === 0) return null;\n\n  const createdAt = Number(meta.createdAt || 0);\n  const mode = (meta.mode === \"shuffle\" ? \"shuffle\" : \"voted\") as \"voted\" | \"shuffle\";\n\n  // nowPlayingJson: be robust\n  let nowPlaying: Track | undefined = undefined;\n  const np = meta.nowPlayingJson || \"\";\n  if (np) {\n    try { nowPlaying = JSON.parse(np) as Track; } catch { nowPlaying = undefined; }\n  }\n\n  const trackIds = await redis.sMembers(kQueue(roomId));\n  if (trackIds.length === 0) return { id: roomId, createdAt, mode, queue: [], nowPlaying };\n\n  const pipe = redis.multi();\n  for (const tid of trackIds) {\n    pipe.hGet(kTracks(roomId), tid);\n    pipe.hGet(kAdded(roomId), tid);\n    pipe.sCard(kUp(roomId, tid));\n    pipe.sCard(kDown(roomId, tid));\n  }\n\n  // IMPORTANT: node-redis v4 returns raw values, not [err, val] tuples\n  const res = (await pipe.exec()) as any[];\n  const queue: Track[] = [];\n\n  for (let i = 0; i < trackIds.length; i++) {\n    const tid = trackIds[i];\n\n    const json = res[i * 4 + 0] as string | null;\n    const addedAtStr = res[i * 4 + 1] as string | null;\n    const up = Number(res[i * 4 + 2] ?? 0);\n    const down = Number(res[i * 4 + 3] ?? 0);\n\n    if (!json) continue;\n\n    try {\n      const base = JSON.parse(json) as Omit<Track, \"votes\" | \"addedAt\">;\n      queue.push({\n        ...base,\n        votes: up - down,\n        addedAt: Number(addedAtStr ?? Date.now()),\n      });\n    } catch {\n      continue;\n    }\n  }\n\n  queue.sort((a, b) => (b.votes - a.votes) || (a.addedAt - b.addedAt));\n  return { id: roomId, createdAt, mode, queue, nowPlaying };\n}\n\nexport async function addTrack(roomId: string, t: { id: string; name: string; artist: string; artworkUrl?: string }): Promise<Room> {\n  const redis = await getRedis();\n  if (!(await redis.exists(kMeta(roomId)))) throw new Error(\"Room not found\");\n\n  const isNew = await redis.sAdd(kQueue(roomId), t.id);\n  if (isNew) {\n    await redis.hSet(kTracks(roomId), t.id, JSON.stringify({ id: t.id, name: t.name, artist: t.artist, artworkUrl: t.artworkUrl }));\n    await redis.hSet(kAdded(roomId), t.id, String(Date.now()));\n  }\n\n  const room = await getRoom(roomId);\n  if (!room) throw new Error(\"Room not found\");\n  return room;\n}\n\nexport async function vote(roomId: string, trackId: string, delta: 1 | -1, clientId: string): Promise<Room> {\n  const redis = await getRedis();\n  if (!(await redis.exists(kMeta(roomId)))) throw new Error(\"Room not found\");\n  if (!(await redis.sIsMember(kQueue(roomId), trackId))) throw new Error(\"Track not in queue\");\n\n  if (delta === 1) {\n    const already = await redis.sIsMember(kUp(roomId, trackId), clientId);\n    if (already) await redis.sRem(kUp(roomId, trackId), clientId);\n    else {\n      await redis.sAdd(kUp(roomId, trackId), clientId);\n      await redis.sRem(kDown(roomId, trackId), clientId);\n    }\n  } else {\n    const already = await redis.sIsMember(kDown(roomId, trackId), clientId);\n    if (already) await redis.sRem(kDown(roomId, trackId), clientId);\n    else {\n      await redis.sAdd(kDown(roomId, trackId), clientId);\n      await redis.sRem(kUp(roomId, trackId), clientId);\n    }\n  }\n\n  const room = await getRoom(roomId);\n  if (!room) throw new Error(\"Room not found\");\n  return room;\n}\n\nexport async function setMode(roomId: string, mode: \"voted\" | \"shuffle\", hostKey: string | null): Promise<Room> {\n  await requireHost(roomId, hostKey);\n  const redis = await getRedis();\n  await redis.hSet(kMeta(roomId), { mode });\n  const room = await getRoom(roomId);\n  if (!room) throw new Error(\"Room not found\");\n  return room;\n}\n\nexport async function nextTrack(roomId: string, hostKey: string | null): Promise<{ room: Room; next: Track | null }> {\n  await requireHost(roomId, hostKey);\n  const redis = await getRedis();\n\n  const room = await getRoom(roomId);\n  if (!room) throw new Error(\"Room not found\");\n  if (room.queue.length === 0) return { room, next: null };\n\n  let next: Track | null = null;\n\n  if (room.mode === \"shuffle\") {\n    const tid = await redis.sRandMember(kQueue(roomId));\n    if (!tid) return { room, next: null };\n\n    const json = await redis.hGet(kTracks(roomId), tid);\n    const addedAtStr = await redis.hGet(kAdded(roomId), tid);\n    const up = await redis.sCard(kUp(roomId, tid));\n    const down = await redis.sCard(kDown(roomId, tid));\n\n    if (json) {\n      try {\n        const base = JSON.parse(json) as Omit<Track, \"votes\" | \"addedAt\">;\n        next = { ...base, votes: up - down, addedAt: Number(addedAtStr ?? Date.now()) };\n      } catch {\n        next = null;\n      }\n    }\n\n    await redis.sRem(kQueue(roomId), tid);\n  } else {\n    next = room.queue[0];\n    await redis.sRem(kQueue(roomId), next.id);\n  }\n\n  if (!next) {\n    const updated = await getRoom(roomId);\n    return { room: updated ?? room, next: null };\n  }\n\n  await redis.hSet(kMeta(roomId), { nowPlayingJson: JSON.stringify(next) });\n\n  const updated = await getRoom(roomId);\n  if (!updated) throw new Error(\"Room not found\");\n  return { room: updated, next };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 387, "column": 0}, "map": {"version":3,"sources":["file:///Users/keshuk/Desktop/Aux-Reimagined/app/api/rooms/%5BroomId%5D/vote/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { vote } from \"../../../../../lib/rooms\";\n\nexport const runtime = \"nodejs\";\n\nexport async function POST(req: NextRequest, ctx: { params: Promise<{ roomId: string }> }) {\n  const { roomId } = await ctx.params;\n  const idRoom = (roomId ?? \"\").toUpperCase();\n\n  const clientId = req.headers.get(\"x-client-id\");\n  if (!clientId) return NextResponse.json({ error: \"Missing x-client-id\" }, { status: 400 });\n\n  const body = await req.json();\n  const { trackId, delta } = body ?? {};\n  if (!trackId || (delta !== 1 && delta !== -1)) {\n    return NextResponse.json({ error: \"Need trackId and delta=1|-1\" }, { status: 400 });\n  }\n\n  try {\n    const room = await vote(idRoom, trackId, delta, clientId);\n    return NextResponse.json(room);\n  } catch (e: any) {\n    return NextResponse.json({ error: e?.message ?? \"Error\" }, { status: 404 });\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAEO,MAAM,UAAU;AAEhB,eAAe,KAAK,GAAgB,EAAE,GAA4C;IACvF,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,IAAI,MAAM;IACnC,MAAM,SAAS,CAAC,UAAU,EAAE,EAAE,WAAW;IAEzC,MAAM,WAAW,IAAI,OAAO,CAAC,GAAG,CAAC;IACjC,IAAI,CAAC,UAAU,OAAO,gJAAY,CAAC,IAAI,CAAC;QAAE,OAAO;IAAsB,GAAG;QAAE,QAAQ;IAAI;IAExF,MAAM,OAAO,MAAM,IAAI,IAAI;IAC3B,MAAM,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG,QAAQ,CAAC;IACpC,IAAI,CAAC,WAAY,UAAU,KAAK,UAAU,CAAC,GAAI;QAC7C,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAA8B,GAAG;YAAE,QAAQ;QAAI;IACnF;IAEA,IAAI;QACF,MAAM,OAAO,MAAM,IAAA,sHAAI,EAAC,QAAQ,SAAS,OAAO;QAChD,OAAO,gJAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,GAAQ;QACf,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO,GAAG,WAAW;QAAQ,GAAG;YAAE,QAAQ;QAAI;IAC3E;AACF"}}]
}